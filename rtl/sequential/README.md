# 順序回路 (Sequential Logic)

## はじめに

このディレクトリでは、順序回路の動作記述方法を学習します。
厳密には、順序回路はフリップフロップやレジスタ（まれにラッチ）のみを指しますが、
実際のRTL設計では順序回路と組み合わせ回路を組み合わせた回路を記述します。

**重要**: このチュートリアルの目的は、レジスタがどのように合成され、
他のロジックとの関係でどこに配置されるかを理解することです。
RTL記述で最もよくある間違いの1つが、意図しない数のレジスタを生成してしまうことです。

## 基本原則: 回路を設計してから、コードを書く

順序回路の場合、「回路を設計する」とは、**正確に何個のレジスタが必要か**、
そして**それらのレジスタが何に接続されるか**を決定することを意味します。

合成最適化（リタイミングなど）により多少変更される可能性はありますが、
レジスタの使用は設計の**タイミング**に影響するため、重要な設計判断です。
これはRTL合成では変更できないものです。

構造的アーキテクチャと同様に、順序回路の「回路設計」は通常、
すべてのレジスタの正確な数と配置を示す**回路図を作成すること**を意味します。
この回路図があれば、以下のガイドラインを簡単に適用して、
意図した通りに合成されることを保証できます。

## 学習の推奨順序

凡例: ✓ = サンプル実装済み | 📝 = 演習問題（自分で実装）

### 1. ✓ レジスタ (register.sv)
- **学習内容**:
  - 非同期リセット (asynchronous reset)
  - 同期リセット (synchronous reset)
  - イネーブル/ロード信号
  - 高度にパラメータ化されたレジスタ
  - リセットタイプと活性化レベルの切り替え
- **重要ポイント**:
  - `always_ff`ブロックの使用
  - `posedge`/`negedge`の理解
  - ノンブロッキング代入(`<=`)の使用
- **ファイル**: `register.sv`（8種類の実装例）

### 2. 📝 順序回路の合成例 (seq_examples.sv)
- **学習内容**:
  - 動作記述から特定の構造への合成
  - よくある間違いとその修正方法
  - ブロッキング代入とノンブロッキング代入の使い分け
- **演習**: `register.sv`を参考に、様々な順序回路を実装してRTLビューアで回路図を確認してください

### 3. ✓ カウンタ (counter.sv)
- **学習内容**:
  - アップカウンタ、ダウンカウンタ
  - ロード可能なカウンタ
  - 任意の初期値と上限値
  - イネーブル制御
- **ファイル**: `counter.sv`（10種類の実装例：BCD、グレイコード、ワンホット等）

### 4. 📝 シフトレジスタ (shift_register.sv)
- **学習内容**:
  - 左シフト、右シフト
  - パラレルロード
  - シリアル入力/出力
  - 論理シフトと算術シフト
- **演習**: `counter.sv`を参考に、パラメータ化されたシフトレジスタを実装してください

## レジスタ記述の基本パターン

### パターン1: 非同期リセット付きレジスタ
```systemverilog
always_ff @(posedge clk or posedge rst) begin
    if (rst) begin
        q <= '0;  // リセット時の値
    end else begin
        q <= d;   // 通常動作: dを取り込む
    end
end
```

### パターン2: 同期リセット付きレジスタ
```systemverilog
always_ff @(posedge clk) begin
    if (rst) begin
        q <= '0;  // リセット時の値
    end else begin
        q <= d;   // 通常動作
    end
end
```

### パターン3: イネーブル付きレジスタ
```systemverilog
always_ff @(posedge clk) begin
    if (rst) begin
        q <= '0;
    end else if (en) begin
        q <= d;   // イネーブル時のみ更新
    end
    // en=0のときqは保持される
end
```

### パターン4: レジスタ + 組み合わせ回路
```systemverilog
// 組み合わせ回路
always_comb begin
    next_state = current_state + 1;  // ブロッキング代入
end

// レジスタ
always_ff @(posedge clk) begin
    if (rst)
        current_state <= '0;
    else
        current_state <= next_state;  // ノンブロッキング代入
end
```

## ブロッキング代入 vs ノンブロッキング代入

### ノンブロッキング代入 (`<=`) - 順序回路で使用
- **使用場所**: `always_ff`ブロック内
- **動作**: すべての右辺を評価してから、左辺に代入
- **効果**: レジスタ間の並列動作を正しくシミュレート
- **合成結果**: フリップフロップ/レジスタ

```systemverilog
always_ff @(posedge clk) begin
    a <= b;  // ノンブロッキング
    b <= a;  // ノンブロッキング
    // 結果: aとbが入れ替わる（並列動作）
end
```

### ブロッキング代入 (`=`) - 組み合わせ回路で使用
- **使用場所**: `always_comb`ブロック内
- **動作**: 即座に左辺に代入してから次の文へ
- **効果**: 組み合わせ回路の直列動作を表現
- **合成結果**: 組み合わせ回路（ワイヤ）

```systemverilog
always_comb begin
    temp = a + b;   // ブロッキング
    out = temp * 2; // ブロッキング
    // 結果: out = (a + b) * 2（直列動作）
end
```

## よくある間違いと対策

### 間違い1: 意図しないレジスタ生成
```systemverilog
// 悪い例: always_ffで組み合わせ回路を書く
always_ff @(posedge clk) begin
    sum = a + b;  // 不要なレジスタが生成される!
end

// 良い例: 組み合わせ回路はalways_combで
always_comb begin
    sum = a + b;  // 組み合わせ回路のみ
end
```

### 間違い2: always_combでノンブロッキング代入
```systemverilog
// 悪い例: 組み合わせ回路でノンブロッキング代入
always_comb begin
    out <= a + b;  // エラーまたは警告
end

// 良い例: ブロッキング代入を使用
always_comb begin
    out = a + b;
end
```

### 間違い3: always_ffでブロッキング代入（レース条件の原因）
```systemverilog
// 悪い例: 順序回路でブロッキング代入
always_ff @(posedge clk) begin
    a = b;  // レース条件発生の可能性
    b = a;  // シミュレーション結果が不定
end

// 良い例: ノンブロッキング代入を使用
always_ff @(posedge clk) begin
    a <= b;
    b <= a;  // 正しく入れ替わる
end
```

### 間違い4: 混在したリセット（非同期と同期）
```systemverilog
// 悪い例: 感度リストにrstがあるのに同期的に使用
always_ff @(posedge clk or posedge rst) begin
    if (clk && rst)  // 混乱を招く
        q <= '0;
    else
        q <= d;
end

// 良い例: 非同期リセット
always_ff @(posedge clk or posedge rst) begin
    if (rst)
        q <= '0;
    else
        q <= d;
end

// または同期リセット
always_ff @(posedge clk) begin
    if (rst)
        q <= '0;
    else
        q <= d;
end
```

## リセットの種類と選択

### 非同期リセット (Asynchronous Reset)
- **利点**:
  - クロックなしでリセット可能
  - 確実な初期化
  - FPGA/ASICで一般的
- **欠点**:
  - グリッチに敏感
  - リセット解除タイミングに注意が必要
  - メタスタビリティのリスク

### 同期リセット (Synchronous Reset)
- **利点**:
  - クロックエッジで同期
  - グリッチの影響なし
  - テストが容易
- **欠点**:
  - クロックが必要
  - リソースがわずかに増加

### 推奨事項
- **FPGA**: 非同期リセットが一般的（プリミティブに適合）
- **ASIC**: プロジェクト標準に従う
- **混在は避ける**: 一貫性のあるリセット戦略を使用

## 合成のベストプラクティス

1. **always_ffを使用**: 順序回路には`always_ff`、組み合わせ回路には`always_comb`
2. **ノンブロッキング代入**: `always_ff`内では必ず`<=`を使用
3. **ブロッキング代入**: `always_comb`内では`=`を使用
4. **明確な意図**: レジスタが必要な場所とそうでない場所を明確に区別
5. **リセット戦略**: プロジェクト全体で一貫したリセット方式を使用
6. **初期化**: FPGAの場合、初期値設定を検討（ASIC では通常不可）

## 次のステップ

順序回路を理解したら、次はステートマシンを学習してください:
- **次**: `../fsm/` - 有限ステートマシン (FSM)
- **関連**: `../combinational/` - 組み合わせ回路との組み合わせ
