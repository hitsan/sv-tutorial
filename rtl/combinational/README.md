# 組み合わせ回路 (Combinational Logic)

## はじめに

このディレクトリでは、SystemVerilogで合成可能な組み合わせ回路の記述方法を学習します。
すべての例にはシミュレーション用のテストベンチが含まれています（モジュール名_tb.sv）。

## 基本原則: 回路を設計してから、コードを書く

すべての回路設計において、まず回路を設計し、それからコードを書くことが重要です。
組み合わせ回路の場合、合成ツールが優れた最適化を行うため、同じ回路を多様な方法で記述できますが、
少なくともI/Oインターフェースを考慮してからコーディングを開始すべきです。

## 学習の推奨順序

凡例: ✓ = サンプル実装済み | 📝 = 演習問題（自分で実装）

### 1. ✓ 2:1マルチプレクサ (mux2x1.sv)
- **学習内容**:
  - 組み合わせ回路の基本構文とガイドライン
  - `assign`文による記述
  - `always_comb`ブロックの使用
  - `if`文、`case`文による記述
  - 三項演算子の使用
- **重要ポイント**:
  - SystemVerilogでは1つのモジュールに1つの実装のみ
  - 複数の記述方法が同じ回路を生成
- **ファイル**: `mux2x1.sv`, `mux2x1_tb.sv`

### 2. 📝 4入力プライオリティエンコーダ (priority_encoder_4in.sv)
- **学習内容**:
  - パックド配列 (packed arrays)
  - `if`文と`case`文の使い分け
  - 優先度を持つロジックの実装
- **重要ポイント**:
  - プライオリティロジックには`if`文が適切
  - 等価比較には`case`文が効率的
- **演習**: `mux2x1.sv`を参考に、4入力のプライオリティエンコーダを実装してください

### 3. 📝 パラメータ化プライオリティエンコーダ (priority_encoder.sv)
- **学習内容**:
  - `parameter`による汎用化
  - `always_comb`内での`for`ループ
  - `localparam`の使用
  - 整数からビット幅への変換テクニック
- **重要ポイント**:
  - パラメータで再利用性を向上
  - ビット幅の不一致を避ける方法
- **演習**: priority_encoder_4in.svをパラメータ化して汎用的にしてください

### 4. ✓ 加算器 (adder.sv)
- **学習内容**:
  - 算術演算
  - ブロッキング代入 vs ノンブロッキング代入
  - 連結演算子 (concatenation)
  - 自動変数リサイジング
  - キャリー入力/出力の扱い
  - オーバーフロー検出
- **実装例**:
  - キャリーなし加算器
  - キャリーアウト付き加算器
  - キャリーイン/アウト付き加算器
  - オーバーフロー検出付き加算器
- **ファイル**: `adder.sv`

### 5. 📝 乗算器 (multiplier.sv)
- **学習内容**:
  - `signed`と`unsigned`の扱い
  - `generate`文による繰り返し生成
  - 変数のスコープ
  - スライシング (slicing)
  - `generate`ブロックへの階層アクセス
- **重要ポイント**:
  - 符号付き/符号なし演算の違い
  - 生成ブロックによる構造的記述
- **演習**: `adder.sv`を参考に、符号付き/符号なし乗算器を実装してください

### 6. 📝 ALU (alu.sv)
- **学習内容**:
  - ラッチが生成される一般的な問題
  - ラッチを避ける戦略
  - `task`の使用
  - パッケージ (package)
  - `import`とスコープ解決
- **重要ポイント**:
  - 組み合わせ回路で意図しないラッチを生成しない
  - 完全な条件分岐の重要性
  - デフォルト値の設定
- **演習**: 加算、減算、AND、OR、XOR、シフト演算を持つALUを設計してください

## よくある間違いと対策

### 1. ラッチの意図しない生成
```systemverilog
// 悪い例: outが特定条件でのみ割り当てられる
always_comb begin
    if (sel == 2'b00) out = in0;
    else if (sel == 2'b01) out = in1;
    // sel = 2'b10, 2'b11のときoutは未定義 → ラッチ生成!
end

// 良い例: すべての条件でoutを割り当て
always_comb begin
    case (sel)
        2'b00: out = in0;
        2'b01: out = in1;
        2'b10: out = in2;
        default: out = in3;  // defaultで必ず値を割り当て
    endcase
end
```

### 2. ビット幅の不一致
```systemverilog
// 悪い例: ビット幅が不一致
logic [7:0] a, b;
logic [7:0] sum;
assign sum = a + b;  // 9ビット必要だが8ビットに切り詰め

// 良い例: 適切なビット幅
logic [7:0] a, b;
logic [8:0] sum;
assign sum = a + b;  // キャリーを含む9ビット
```

### 3. 感度リストの不備
```systemverilog
// 悪い例: 古いスタイル
always @(a, b)  // cを忘れると合成とシミュレーションが不一致
    out = a & b | c;

// 良い例: always_combを使用
always_comb
    out = a & b | c;  // すべての信号が自動的に感度リストに含まれる
```

## 合成のベストプラクティス

1. **always_combを使用**: 組み合わせ回路には`always_comb`を使用し、感度リストの問題を回避
2. **完全な条件分岐**: すべての入力条件で出力を定義
3. **デフォルト値の設定**: `always_comb`の最初でデフォルト値を設定
4. **適切なビット幅**: 演算結果が収まる十分なビット幅を確保
5. **パラメータ化**: 再利用性のためにパラメータを活用

## シミュレーションとテスト

各モジュールには対応するテストベンチ（_tb.sv）が用意されています。
テストベンチの詳細は`../../tb/`ディレクトリを参照してください。

### シミュレーション実行例（VCS/Questa/Vivado等）
```bash
# VCS例
vcs -sverilog mux2x1.sv mux2x1_tb.sv
./simv

# Questa例
vlog -sv mux2x1.sv mux2x1_tb.sv
vsim -c work.mux2x1_tb -do "run -all; quit"
```

## 参考資料

- IEEE 1800-2017 SystemVerilog LRM
- 詳細な説明は各ソースファイル内のコメントを参照
- テストベンチの書き方: `../../tb/README.md`

## 次のステップ

組み合わせ回路を理解したら、次は順序回路を学習してください:
- **次**: `../sequential/` - レジスタとフリップフロップ
- **関連**: `../structural/` - 構造的記述による回路の組み立て
