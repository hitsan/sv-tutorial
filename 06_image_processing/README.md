# 画像処理 (Image Processing)

## はじめに

このディレクトリでは、画像処理の基礎となる畳み込み演算とフィルタリングを学習します。
2次元の画像データに対する演算を、1次元のストリーム処理として実装する方法を理解することが重要です。

画像処理のハードウェア実装は、リアルタイム処理（カメラ、ビデオ等）において必須の技術です。

## 基本原則: 回路を設計してから、コードを書く

画像処理回路の設計では、まず**データフロー**を明確にすることが重要です。
特に、2次元データを1次元ストリームとして処理するための**ラインバッファ**の設計が鍵となります。

回路図を描く際は、以下を明確にします：
1. ラインバッファのサイズ（画像幅に依存）
2. ウィンドウレジスタの配置
3. 演算回路（乗算器、加算器の数）
4. ストリーミングインターフェース（valid/ready信号）

## 学習の推奨順序

### 1. 3x3 Convolution (conv3x3/conv3x3.sv)
- **概要**: 3x3カーネルによる2次元畳み込み演算の基本実装
- **学習内容**:
  - 2次元データの1次元ストリーム処理
  - ラインバッファ（2行分のシフトレジスタ）の実装
  - ウィンドウスライディング（3x3の窓を画像上で移動）
  - カーネル係数とのパラレル乗算
  - 加算ツリーによる畳み込み演算
  - ストリーミングインターフェース（valid信号）
- **重要ポイント**:
  - ラインバッファは画像幅分のシフトレジスタ
  - 3x3ウィンドウを構成するため、2行分のラインバッファが必要
  - エッジ処理（画像の端）は簡略化のためゼロパディング
  - カーネル係数はパラメータで変更可能
- **実装例**:
  - 画像幅8ピクセル（教育用に簡素化）
  - パラメータ化されたカーネル係数
  - ストリーミング入出力
- **ファイル**: `conv3x3/conv3x3.sv`, `conv3x3/conv3x3_tb.sv`

### 2. Sobel Filter (sobel_filter/sobel_filter.sv)
- **概要**: Sobelオペレータによるエッジ検出フィルタ
- **学習内容**:
  - conv3x3モジュールの再利用（構造記述）
  - 固定カーネル係数の設定（Gx, Gy）
  - 勾配強度の計算（|Gx| + |Gy|の近似）
  - 絶対値演算の実装
  - 複数フィルタの統合
  - 04_structuralで学んだモジュールインスタンス化の応用
- **重要ポイント**:
  - Sobelカーネル（Gx: 水平方向、Gy: 垂直方向）
  - 2つのconv3x3インスタンスを使用
  - 勾配強度は近似式を使用（|Gx| + |Gy|）
  - 真の勾配は√(Gx² + Gy²) だが、計算コストが高い
- **実装例**:
  - conv3x3を2インスタンス使用
  - Gx, Gyカーネルを固定係数として設定
  - 絶対値 + 加算による勾配強度計算
- **ファイル**: `sobel_filter/sobel_filter.sv`, `sobel_filter/sobel_filter_tb.sv`

## 畳み込み演算の基礎

### 2D畳み込み演算

3x3カーネルKと画像Iの畳み込み：

```
O(x,y) = ΣΣ K(i,j) * I(x+i, y+j)  (i,j = -1 to 1)
```

例: 3x3平滑化カーネル（すべて1/9）
```
K = [1 1 1]     1
    [1 1 1]  ×  -
    [1 1 1]     9
```

### Sobelオペレータ

エッジ検出用のカーネル：

**水平方向（Gx）**:
```
Gx = [-1  0  +1]
     [-2  0  +2]
     [-1  0  +1]
```

**垂直方向（Gy）**:
```
Gy = [-1 -2 -1]
     [ 0  0  0]
     [+1 +2 +1]
```

**勾配強度**:
- 正確: G = √(Gx² + Gy²)
- 近似: G ≈ |Gx| + |Gy|（ハードウェア実装で一般的）

## ラインバッファの仕組み

3x3畳み込みを実現するには、3行分のデータが同時に必要です。
ストリーミング処理では、過去2行分をラインバッファに保持します。

```
           画像幅
        ←--------→
Row N-2: □□□□□□□□  ← Line Buffer 0
Row N-1: □□□□□□□□  ← Line Buffer 1
Row N  : □□□□□□□□  ← 現在の入力
         ↑
      3x3 Window
```

各ピクセル入力時：
1. 現在のピクセルを受信
2. Line Buffer 1から1ピクセル読み出し
3. Line Buffer 0から1ピクセル読み出し
4. 3x3ウィンドウを構成
5. カーネルとの畳み込み演算
6. Line Bufferをシフト

## ベストプラクティス

1. **ラインバッファサイズ**: 画像幅をパラメータ化し、柔軟に対応
2. **ウィンドウ有効性**: 最初の2行+2ピクセルは無効（ウォームアップ期間）
3. **固定小数点演算**: カーネル係数を整数で表現し、最後にスケーリング
4. **パイプライン化**: 乗算と加算の間にレジスタを挿入して高速化
5. **エッジ処理**: ゼロパディング、ミラーリング、クランプなど適切に選択

## よくある間違いと対策

### 間違い1: ラインバッファサイズの誤り

```systemverilog
// 悪い例: 固定サイズ
logic [7:0] line_buffer_0 [0:7];  // 8ピクセル固定

// 良い例: パラメータ化
parameter int IMAGE_WIDTH = 8;
logic [7:0] line_buffer_0 [0:IMAGE_WIDTH-1];
```

### 間違い2: ウィンドウ有効性の考慮不足

```systemverilog
// 悪い例: 最初から出力を有効とする
assign valid_out = valid_in;  // 最初の2行は無効なデータ

// 良い例: ウォームアップ期間を考慮
logic [15:0] pixel_count;
assign valid_out = valid_in && (pixel_count >= 2*IMAGE_WIDTH + 2);
```

### 間違い3: カーネル係数のスケーリング忘れ

```systemverilog
// 悪い例: 係数の合計を考慮しない
// 平滑化カーネルの合計が9なので、出力が9倍になる
output_pixel = sum;

// 良い例: 適切にスケーリング
output_pixel = sum / 9;  // または右シフト
```

### 間違い4: ビット幅の不足

```systemverilog
// 悪い例: 累算でオーバーフロー
logic [7:0] sum;
sum = k00*p00 + k01*p01 + ... + k22*p22;  // 9項の加算

// 良い例: 十分なビット幅
logic [7+8+4:0] sum;  // pixel(8bit) * coeff(8bit) * 9項
```

## パフォーマンス考慮事項

| 項目 | 値（例） | 説明 |
|------|---------|------|
| レイテンシ | 2行+3ピクセル | ラインバッファ充填に必要 |
| スループット | 1ピクセル/サイクル | valid_in=1の場合 |
| リソース | 9乗算器 + 加算ツリー | 3x3カーネル用 |
| メモリ | 2×画像幅 | ラインバッファ |

## 応用例

1. **平滑化フィルタ**: ノイズ除去
2. **エッジ検出**: Sobel, Prewitt, Laplacian
3. **シャープニング**: エッジ強調
4. **エンボス**: 浮き彫り効果
5. **モーションブラー**: 動きのぼかし

## 参考資料

- Digital Image Processing - Gonzalez & Woods
- Computer Vision: Algorithms and Applications - Szeliski
- IEEE 1800-2017 SystemVerilog LRM
- 詳細な説明は各ソースファイル内のコメントを参照
