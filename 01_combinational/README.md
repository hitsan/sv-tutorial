# 組み合わせ回路 (Combinational Logic)

## はじめに

このディレクトリでは、SystemVerilogで合成可能な組み合わせ回路の記述方法を学習します。
すべての例にはシミュレーション用のテストベンチが含まれています（モジュール名_tb.sv）。

## 基本原則: 回路を設計してから、コードを書く

すべての回路設計において、まず回路を設計し、それからコードを書くことが重要です。
組み合わせ回路の場合、合成ツールが優れた最適化を行うため、同じ回路を多様な方法で記述できますが、
少なくともI/Oインターフェースを考慮してからコーディングを開始すべきです。

## 学習の推奨順序

### 1. 2:1マルチプレクサ (mux2x1/mux2x1.sv)
- **概要**: セレクタ信号に基づいて2つの入力から1つを選択して出力する回路
- **学習内容**:
  - 組み合わせ回路の基本構文とガイドライン
  - `assign`文による記述
  - `always_comb`ブロックの使用
  - `if`文、`case`文による記述
  - 三項演算子の使用
- **重要ポイント**:
  - SystemVerilogでは1つのモジュールに1つの実装のみ
  - 複数の記述方法が同じ回路を生成
- **ファイル**: `mux2x1/mux2x1.sv`, `mux2x1/mux2x1_tb.sv`

### 2. 4入力プライオリティエンコーダ (priority_encoder/)
- **概要**: 複数の入力のうち最も優先度の高い（最上位ビット）入力の位置を符号化して出力する回路
- **学習内容**:
  - パックド配列 (packed arrays)
  - `if`文と`case`文の使い分け
  - 優先度を持つロジックの実装
- **重要ポイント**:
  - プライオリティロジックには`if`文が適切
  - 等価比較には`case`文が効率的
- **実装例**:
  - `if`文による実装: `priority_encoder_4in_if.sv`
  - `case`文による実装: `priority_encoder_4in_case.sv`

### 3. パラメータ化プライオリティエンコーダ (priority_encoder/priority_encoder.sv)
- **概要**: 入力ビット幅をパラメータで変更可能にした汎用的なプライオリティエンコーダ
- **学習内容**:
  - `parameter`による汎用化
  - `always_comb`内での`for`ループ
  - `localparam`の使用
  - 整数からビット幅への変換テクニック
- **重要ポイント**:
  - パラメータで再利用性を向上
  - ビット幅の不一致を避ける方法
- **ファイル**: `priority_encoder/priority_encoder.sv`, `priority_encoder/priority_encoder_tb.sv`

### 4. 加算器 (adder/adder.sv)
- **概要**: 2つの数値を加算し、キャリーやオーバーフローを検出できる算術演算回路
- **学習内容**:
  - 算術演算
  - ブロッキング代入 vs ノンブロッキング代入
  - 連結演算子 (concatenation)
  - 自動変数リサイジング
  - キャリー入力/出力の扱い
  - オーバーフロー検出
- **実装例**:
  - キャリーなし加算器
  - キャリーアウト付き加算器
  - キャリーイン/アウト付き加算器
  - オーバーフロー検出付き加算器
- **ファイル**: `adder/adder.sv`

### 5. 乗算器 (multiplier/multiplier.sv)
- **概要**: 2つの数値を乗算する算術演算回路（符号付き/符号なしに対応）
- **学習内容**:
  - `signed`と`unsigned`の扱い
  - `generate`文による繰り返し生成
  - 変数のスコープ
  - スライシング (slicing)
  - `generate`ブロックへの階層アクセス
- **重要ポイント**:
  - 符号付き/符号なし演算の違い
  - 生成ブロックによる構造的記述
- **ファイル**: `multiplier/multiplier.sv`, `multiplier/multiplier_tb.sv`

### 6. ALU (alu/alu.sv)
- **概要**: 演算コードに基づいて複数の算術論理演算を実行できる演算装置（Arithmetic Logic Unit）
- **学習内容**:
  - ラッチが生成される一般的な問題
  - ラッチを避ける戦略
  - `task`の使用
  - パッケージ (package)
  - `import`とスコープ解決
- **重要ポイント**:
  - 組み合わせ回路で意図しないラッチを生成しない
  - 完全な条件分岐の重要性
  - デフォルト値の設定
- **実装例**: 加算、減算、AND、OR、XOR、シフト演算を持つALU
- **ファイル**: `alu/alu.sv`, `alu/alu_pkg.sv`, `alu/alu_tb.sv`

## よくある間違いと対策

### 1. ラッチの意図しない生成
```systemverilog
// 悪い例: outが特定条件でのみ割り当てられる
always_comb begin
    if (sel == 2'b00) out = in0;
    else if (sel == 2'b01) out = in1;
    // sel = 2'b10, 2'b11のときoutは未定義 → ラッチ生成!
end

// 良い例: すべての条件でoutを割り当て
always_comb begin
    case (sel)
        2'b00: out = in0;
        2'b01: out = in1;
        2'b10: out = in2;
        default: out = in3;  // defaultで必ず値を割り当て
    endcase
end
```

### 2. ビット幅の不一致
```systemverilog
// 悪い例: ビット幅が不一致
logic [7:0] a, b;
logic [7:0] sum;
assign sum = a + b;  // 9ビット必要だが8ビットに切り詰め

// 良い例: 適切なビット幅
logic [7:0] a, b;
logic [8:0] sum;
assign sum = a + b;  // キャリーを含む9ビット
```

### 3. 感度リストの不備
```systemverilog
// 悪い例: 古いスタイル
always @(a, b)  // cを忘れると合成とシミュレーションが不一致
    out = a & b | c;

// 良い例: always_combを使用
always_comb
    out = a & b | c;  // すべての信号が自動的に感度リストに含まれる
```

## 合成のベストプラクティス

1. **always_combを使用**: 組み合わせ回路には`always_comb`を使用し、感度リストの問題を回避
2. **完全な条件分岐**: すべての入力条件で出力を定義
3. **デフォルト値の設定**: `always_comb`の最初でデフォルト値を設定
4. **適切なビット幅**: 演算結果が収まる十分なビット幅を確保
5. **パラメータ化**: 再利用性のためにパラメータを活用

## 参考資料

- IEEE 1800-2017 SystemVerilog LRM
- 詳細な説明は各ソースファイル内のコメントを参照
