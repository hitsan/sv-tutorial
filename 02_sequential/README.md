# 順序回路 (Sequential Logic)

## はじめに

このディレクトリでは、順序回路の動作記述方法を学習します。
厳密には、順序回路はフリップフロップやレジスタ（まれにラッチ）のみを指しますが、
実際のRTL設計では順序回路と組み合わせ回路を組み合わせた回路を記述します。

**重要**: このチュートリアルの目的は、レジスタがどのように合成され、
他のロジックとの関係でどこに配置されるかを理解することです。
RTL記述で最もよくある間違いの1つが、意図しない数のレジスタを生成してしまうことです。

## 基本原則: 回路を設計してから、コードを書く

順序回路の場合、「回路を設計する」とは、**正確に何個のレジスタが必要か**、
そして**それらのレジスタが何に接続されるか**を決定することを意味します。

合成最適化（リタイミングなど）により多少変更される可能性はありますが、
レジスタの使用は設計の**タイミング**に影響するため、重要な設計判断です。
これはRTL合成では変更できないものです。

構造的アーキテクチャと同様に、順序回路の「回路設計」は通常、
すべてのレジスタの正確な数と配置を示す**回路図を作成すること**を意味します。
この回路図があれば、以下のガイドラインを簡単に適用して、
意図した通りに合成されることを保証できます。

## 学習の推奨順序

凡例: ✓ = サンプル実装済み (examples/) | 📝 = 演習問題 (exercises/ → solutions/)

### 1. ✓ レジスタ (examples/register.sv)
- **学習内容**:
  - 非同期リセット (asynchronous reset)
  - 同期リセット (synchronous reset)
  - イネーブル/ロード信号
  - 高度にパラメータ化されたレジスタ
  - リセットタイプと活性化レベルの切り替え
- **重要ポイント**:
  - `always_ff`ブロックの使用
  - `posedge`/`negedge`の理解
  - ノンブロッキング代入(`<=`)の使用
- **ファイル**: `examples/register.sv`（8種類の実装例）

### 2. 📝 順序回路の合成例 (exercises/seq_examples.sv)
- **学習内容**:
  - 動作記述から特定の構造への合成
  - よくある間違いとその修正方法
  - ブロッキング代入とノンブロッキング代入の使い分け
- **演習**: `examples/register.sv`を参考に、様々な順序回路を実装してRTLビューアで回路図を確認してください
- **解答**: `solutions/seq_examples.sv`（詰まったら参照）

### 3. ✓ カウンタ (examples/counter.sv)
- **学習内容**:
  - アップカウンタ、ダウンカウンタ
  - ロード可能なカウンタ
  - 任意の初期値と上限値
  - イネーブル制御
- **ファイル**: `examples/counter.sv`（10種類の実装例：BCD、グレイコード、ワンホット等）

### 4. 📝 シフトレジスタ (exercises/shift_register.sv)
- **学習内容**:
  - 左シフト、右シフト
  - パラレルロード
  - シリアル入力/出力
  - 論理シフトと算術シフト
- **演習**: `examples/counter.sv`を参考に、パラメータ化されたシフトレジスタを実装してください
- **解答**: `solutions/shift_register.sv`（詰まったら参照）

### 5. 📝 パイプライン化された乗算器 (exercises/multiplier_pipelined.sv)
- **学習内容**:
  - パイプライン化の基本概念
  - レイテンシとスループットの違い
  - 組み合わせ回路から順序回路への変換
  - タイミング改善とクリティカルパスの分割
  - generate文と順序回路の組み合わせ
- **重要ポイント**:
  - レイテンシ: データが入力されてから出力されるまでのクロック数
  - スループット: 1クロックあたりに処理できるデータ数
  - パイプラインステージの設計
- **演習**: `../combinational/exercises/multiplier.sv`を参考に、2ステージパイプライン版を実装してください
- **解答**: `solutions/multiplier_pipelined.sv`（詰まったら参照）

### 6. 📝 パイプライン化された乗算器の各種実装
- **学習内容**:
  - 様々なパイプライン化アーキテクチャの比較
  - アレイ乗算器 (Systolic Array)
  - レイテンシとスループットのトレードオフ
  - パイプラインステージ数と複雑度のバランス

- **2つの実装バリアント**:
  1. **Multi-Stage Pipeline (3段)**: 基本的な3ステージパイプライン
     - 2ステージを3ステージに拡張
     - ステージ数増加によるクリティカルパス短縮
     - レイテンシ: 3 cycles

  2. **Array Multiplier**: シストリックアレイ構造
     - 規則的な2次元配列構造
     - 各行が1パイプラインステージ
     - レイテンシ: 8 cycles (INPUT_WIDTH)

- **比較表**:

| 実装方式 | レイテンシ | ステージ数 | 複雑度 | 規則性 | 学習焦点 |
|---------|----------|----------|-------|-------|---------|
| Multi-Stage | 3 | 3 | 低 | 高 | パイプライン基礎 |
| Array | 8 | 8 | 中 | 最高 | シストリックアレイ |

- **重要な学習ポイント**:
  - **ステージ数の影響**: ステージ数を増やすとレイテンシが増加するが、各ステージの処理が単純化される
  - **規則性と設計の容易さ**: Array Multiplierは最も規則的で、設計・検証が容易
  - **トレードオフ**: レイテンシ vs 複雑度 vs 規則性
  - **パイプラインアーキテクチャ**: 基本的なMulti-Stageから規則的なArrayまでの比較

- **Array Multiplierの詳細**:
  - 小学校の筆算と同じ構造
  - 各セルが単純な1ビット乗算+加算
  - パイプラインレジスタを各行に配置
  - スケーラブルで理解しやすい
  - 規則的な構造のため設計・検証が容易

- **演習**: 2つの実装を完成させ、動作を比較してください
  - 各アーキテクチャの特徴を理解する
  - レイテンシの違いを確認する
  - 全バリアントが同じ結果を出力することを検証する

- **実装ファイル**:
  - `multiplier_pipelined_multistage.sv`
  - `multiplier_pipelined_array.sv`

- **テストベンチ**:
  - `multiplier_pipelined_multistage_tb.sv`
  - `multiplier_pipelined_array_tb.sv`
  - 基本・境界値・パターン・ランダムテスト

- **解答**: `solutions/multiplier_pipelined_variants.sv`（詰まったら参照）

## レジスタ記述の基本パターン

### パターン1: 非同期リセット付きレジスタ
```systemverilog
always_ff @(posedge clk or posedge rst) begin
    if (rst) begin
        q <= '0;  // リセット時の値
    end else begin
        q <= d;   // 通常動作: dを取り込む
    end
end
```

### パターン2: 同期リセット付きレジスタ
```systemverilog
always_ff @(posedge clk) begin
    if (rst) begin
        q <= '0;  // リセット時の値
    end else begin
        q <= d;   // 通常動作
    end
end
```

### パターン3: イネーブル付きレジスタ
```systemverilog
always_ff @(posedge clk) begin
    if (rst) begin
        q <= '0;
    end else if (en) begin
        q <= d;   // イネーブル時のみ更新
    end
    // en=0のときqは保持される
end
```

### パターン4: レジスタ + 組み合わせ回路
```systemverilog
// 組み合わせ回路
always_comb begin
    next_state = current_state + 1;  // ブロッキング代入
end

// レジスタ
always_ff @(posedge clk) begin
    if (rst)
        current_state <= '0;
    else
        current_state <= next_state;  // ノンブロッキング代入
end
```

## ブロッキング代入 vs ノンブロッキング代入

### ノンブロッキング代入 (`<=`) - 順序回路で使用
- **使用場所**: `always_ff`ブロック内
- **動作**: すべての右辺を評価してから、左辺に代入
- **効果**: レジスタ間の並列動作を正しくシミュレート
- **合成結果**: フリップフロップ/レジスタ

```systemverilog
always_ff @(posedge clk) begin
    a <= b;  // ノンブロッキング
    b <= a;  // ノンブロッキング
    // 結果: aとbが入れ替わる（並列動作）
end
```

### ブロッキング代入 (`=`) - 組み合わせ回路で使用
- **使用場所**: `always_comb`ブロック内
- **動作**: 即座に左辺に代入してから次の文へ
- **効果**: 組み合わせ回路の直列動作を表現
- **合成結果**: 組み合わせ回路（ワイヤ）

```systemverilog
always_comb begin
    temp = a + b;   // ブロッキング
    out = temp * 2; // ブロッキング
    // 結果: out = (a + b) * 2（直列動作）
end
```

## よくある間違いと対策

### 間違い1: 意図しないレジスタ生成
```systemverilog
// 悪い例: always_ffで組み合わせ回路を書く
always_ff @(posedge clk) begin
    sum = a + b;  // 不要なレジスタが生成される!
end

// 良い例: 組み合わせ回路はalways_combで
always_comb begin
    sum = a + b;  // 組み合わせ回路のみ
end
```

### 間違い2: always_combでノンブロッキング代入
```systemverilog
// 悪い例: 組み合わせ回路でノンブロッキング代入
always_comb begin
    out <= a + b;  // エラーまたは警告
end

// 良い例: ブロッキング代入を使用
always_comb begin
    out = a + b;
end
```

### 間違い3: always_ffでブロッキング代入（レース条件の原因）
```systemverilog
// 悪い例: 順序回路でブロッキング代入
always_ff @(posedge clk) begin
    a = b;  // レース条件発生の可能性
    b = a;  // シミュレーション結果が不定
end

// 良い例: ノンブロッキング代入を使用
always_ff @(posedge clk) begin
    a <= b;
    b <= a;  // 正しく入れ替わる
end
```

### 間違い4: 混在したリセット（非同期と同期）
```systemverilog
// 悪い例: 感度リストにrstがあるのに同期的に使用
always_ff @(posedge clk or posedge rst) begin
    if (clk && rst)  // 混乱を招く
        q <= '0;
    else
        q <= d;
end

// 良い例: 非同期リセット
always_ff @(posedge clk or posedge rst) begin
    if (rst)
        q <= '0;
    else
        q <= d;
end

// または同期リセット
always_ff @(posedge clk) begin
    if (rst)
        q <= '0;
    else
        q <= d;
end
```

## リセットの種類と選択

### 非同期リセット (Asynchronous Reset)
- **利点**:
  - クロックなしでリセット可能
  - 確実な初期化
  - FPGA/ASICで一般的
- **欠点**:
  - グリッチに敏感
  - リセット解除タイミングに注意が必要
  - メタスタビリティのリスク

### 同期リセット (Synchronous Reset)
- **利点**:
  - クロックエッジで同期
  - グリッチの影響なし
  - テストが容易
- **欠点**:
  - クロックが必要
  - リソースがわずかに増加

### 推奨事項
- **FPGA**: 非同期リセットが一般的（プリミティブに適合）
- **ASIC**: プロジェクト標準に従う
- **混在は避ける**: 一貫性のあるリセット戦略を使用

## 合成のベストプラクティス

1. **always_ffを使用**: 順序回路には`always_ff`、組み合わせ回路には`always_comb`
2. **ノンブロッキング代入**: `always_ff`内では必ず`<=`を使用
3. **ブロッキング代入**: `always_comb`内では`=`を使用
4. **明確な意図**: レジスタが必要な場所とそうでない場所を明確に区別
5. **リセット戦略**: プロジェクト全体で一貫したリセット方式を使用
6. **初期化**: FPGAの場合、初期値設定を検討（ASIC では通常不可）

## パイプライン化の基本

パイプラインは、組み合わせ回路の長いクリティカルパスを複数のステージに分割し、
動作周波数を向上させる重要な設計手法です。

### パイプライン化の目的

1. **動作周波数の向上**: クリティカルパスを短縮
2. **スループットの向上**: 並列処理により単位時間あたりの処理量を増加
3. **タイミング制約の達成**: FPGA/ASICで要求される周波数を満たす

### レイテンシ vs スループット

```
組み合わせ回路:
入力 → [長い組み合わせ回路] → 出力
- レイテンシ: 1サイクル（ただしクロック周波数が低い）
- スループット: 1結果/サイクル

2ステージパイプライン:
入力 → [REG] → [組み合わせ回路1] → [REG] → [組み合わせ回路2] → 出力
- レイテンシ: 2サイクル
- スループット: 1結果/サイクル（周波数は2倍可能）
```

### パイプライン化の例: multiplier

**組み合わせ回路版** (`../combinational/exercises/multiplier.sv`):
```systemverilog
// クリティカルパス: 入力 → 乗算 → 出力
always_comb begin
  product = in0 * in1;  // 1サイクルで完了（低周波数）
end
```

**2ステージパイプライン版** (`exercises/multiplier_pipelined.sv`):
```systemverilog
// Stage 1: 入力レジスタ
always_ff @(posedge clk) begin
  in0_r <= in0;
  in1_r <= in1;
end

// Stage 2: 演算 + 出力レジスタ
always_ff @(posedge clk) begin
  product_r <= in0_r * in1_r;
end
```

**効果**:
- クリティカルパス: レジスタ → 乗算 → レジスタ（短縮される）
- レイテンシ: 2クロック（データが2サイクル遅れる）
- スループット: 1結果/クロック（毎サイクル新しい入力を受け付け可能）
- 動作周波数: 最大2倍（理論値）

### パイプライン設計のポイント

1. **ステージ数の決定**:
   - ステージ数を増やす → 周波数向上、レイテンシ増加
   - バランスが重要（用途に応じて調整）

2. **各ステージの負荷均等化**:
   - 各ステージの組み合わせ回路の遅延を揃える
   - 不均等だと最も遅いステージがボトルネックになる

3. **制御信号の同期**:
   - データと制御信号を同じステージ数だけ遅延させる
   - valid/ready信号などのハンドシェイクを適切に処理

4. **リソースとのトレードオフ**:
   - パイプラインレジスタが追加で必要（面積増加）
   - 高周波数動作による消費電力の変化

### よくある用途

- **算術演算**: 乗算器、除算器、浮動小数点演算
- **データパス**: 信号処理、画像処理、暗号化
- **メモリアクセス**: キャッシュ、メモリコントローラ
- **プロセッサ**: 命令フェッチ、デコード、実行、ライトバック

## 次のステップ

順序回路を理解したら、次はステートマシンを学習してください:
- **次**: `../fsm/` - 有限ステートマシン (FSM)
- **関連**: `../combinational/` - 組み合わせ回路との組み合わせ
